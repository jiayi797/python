Python 3.3.2 (v3.3.2:d047928ae3f6, May 16 2013, 00:03:43) [MSC v.1600 32 bit (Intel)] on win32
Type "copyright", "credits" or "license()" for more information.
>>> # -*- coding: utf-8 -*-  
#---------------------------------------  
#   程序：北京邮电大学爬虫  
#   版本：0.1  
#   作者：jiayi797  
#   日期：2013-12-08 
#   语言：Python 3.3  
#   操作：输入学号和密码  
#   功能：输出成绩的加权平均值也就是绩点   
#---------------------------------------  
  
import urllib
#-----------------------------------------------------------------------------------------------------
#   import 的实质
#   import的过程实际上包括两个主要部分,
#   1) 类似于shell 的 "source" 命令, 具体说即相当于将被import的module(即python文件)在当前环境下执行一遍.
#   当多次import同一个module时, python会保证只执行一次. 参考Example1
#   2) import的第二个部分是使被import的成员(变量名, 函数名, 类....)可见.
#   为保证不发生命名冲突, 需要以 module.name 的方式访问导入的成员
#   URI的概念和举例
#   简单的来讲，URL就是在浏览器端输入的    www.baidu.com    这个字符串。
#   在理解URL之前，首先要理解URI的概念。
#   Web上每种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个通用资源标志符(Universal Resource Identifier， URI)进行定位。 
#   URI通常由三部分组成：
#   ①访问资源的命名机制；
#   ②存放资源的主机名；
#   ③资源自身 的名称，由路径表示。
#   如下面的URI：http://www.why.com.cn/myhtml/html1223/
#   我们可以这样解释它：
#   ①这是一个可以通过HTTP协议访问的资源，
#   ②位于主机 www.webmonkey.com.cn上，
#   ③通过路径“/html/html40”访问。 '''
#-----------------------------------------------------------------------------------------------------

#   URL是URI的一个子集。它是Uniform Resource Locator的缩写，译为“统一资源定位 符”。
#   通俗地说，URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。
#   采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。
#   URL的格式由三部分组成： 
#   ①第一部分是协议(或称为服务方式)。
#   ②第二部分是存有该资源的主机IP地址(有时也包括端口号)。
#   ③第三部分是主机资源的具体地址，如目录和文件名等。
#   第一部分和第二部分用“://”符号隔开，
#   第二部分和第三部分用“/”符号隔开。
#   第一部分和第二部分是不可缺少的，第三部分有时可以省略。 
#-----------------------------------------------------------------------------------------------------
import urllib2  
import cookielib  
import re  
  
class SDU_Spider:    
    # 申明相关的属性    
    def __init__(self):      
        self.loginUrl = 'http://211.68.70.198:8080/pls/wwwbks/bks_login2.login'   # 登录的url  
        self.resultUrl = 'http://211.68.70.198:8080/pls/wwwbks/bkscjcx.curscopre' # 显示成绩的url  
        self.cookieJar = cookielib.CookieJar()                                      # 初始化一个CookieJar来处理Cookie的信息  
        self.postdata=urllib.urlencode({'stuid':'2012210031','pwd':'老师我怎么能告诉你密码'})     # POST的数据  
        self.weights = []   #存储权重，也就是学分  
        self.points = []    #存储分数，也就是成绩  
        self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.cookieJar))
#-----------------------------------------------------------------------------------------------------
两个重要概念：Openers和Handlers。
1.Openers：
当你获取一个URL你使用一个opener(一个urllib2.OpenerDirector的实例)。
正常情况下，我们使用默认opener：通过urlopen。
但你能够创建个性的openers。
2.Handles：
Openers使用处理器handlers，所有的“繁重”工作由handlers处理。
每个handlers知道如何通过特定协议打开URLs，或者如何处理URL打开时的各个方面。
例如HTTP重定向或者HTTP cookies。

如果你希望用特定处理器获取URLs你会想创建一个openers，例如获取一个能处理cookie的opener，或者获取一个不重定向的opener。

要创建一个 opener，可以实例化一个OpenerDirector，
然后调用.add_handler(some_handler_instance)。
同样，可以使用build_opener，这是一个更加方便的函数，用来创建opener对象，他只需要一次函数调用。
build_opener默认添加几个处理器，但提供快捷的方法来添加或更新默认处理器。
其他的处理器handlers你或许会希望处理代理，验证，和其他常用但有点特殊的情况。

install_opener 用来创建（全局）默认opener。这个表示调用urlopen将使用你安装的opener。
Opener对象有一个open方法。
该方法可以像urlopen函数那样直接用来获取urls：通常不必调用install_opener，除了为了方便。
#-----------------------------------------------------------------------------------------------------  
    def sdu_init(self):  
        # 初始化链接并且获取cookie  
        myRequest = urllib2.Request(url = self.loginUrl,data = self.postdata)   # 自定义一个请求  
        result = self.opener.open(myRequest)            # 访问登录页面，获取到必须的cookie的值  
        result = self.opener.open(self.resultUrl)       # 访问成绩页面，获得成绩的数据  
        # 打印返回的内容  
        # print result.read()  
        self.deal_data(result.read().decode('gbk'))  
        self.print_data(self.weights);  
        self.print_data(self.points);  
#-----------------------------------------------------------------------------------------------------
#   正则表达式是用于处理字符串的强大工具，它并不是Python的一部分。
#   其他编程语言中也有正则表达式的概念，区别只在于不同的编程语言实现支持的语法数量不同。
#   它拥有自己独特的语法以及一个独立的处理引擎，在提供了正则表达式的语言里，正则表达式的语法都是一样的.
#   正则表达式的大致匹配过程是：
#   1.依次拿出表达式和文本中的字符比较，
#   2.如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。
#   3.如果表达式中有量词或边界，这个过程会稍微有一些不同。
#   Python通过re模块提供对正则表达式的支持。
#   使用re的一般步骤是：
#   Step1：先将正则表达式的字符串形式编译为Pattern实例。
#   Step2：然后使用Pattern实例处理文本并获得匹配结果（一个Match实例）。
#   Step3：最后使用Match实例获得信息，进行其他的操作。
#-----------------------------------------------------------------------------------------------------
    # 将内容从页面代码中抠出来    
    def deal_data(self,myPage):    
        myItems = re.findall('<TR>.*?<p.*?<p.*?<p.*?<p.*?<p.*?>(.*?)</p>.*?<p.*?<p.*?>(.*?)</p>.*?</TR>',myPage,re.S)     #获取到学分  
        for item in myItems:  
            self.weights.append(item[0].encode('gbk'))  
            self.points.append(item[1].encode('gbk'))  
  
              
    # 将内容从页面代码中抠出来  
    def print_data(self,items):    
        for item in items:    
            print item  
              
#调用    
mySpider = SDU_Spider()    
mySpider.sdu_init()    
